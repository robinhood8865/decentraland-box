import { JSONSchema, ValidateFunction } from '../../validation';
import { Rarity } from '../../dapps/rarity';
import { WearableCategory } from '../../dapps/wearable-category';
import { I18N } from './i18n';
import { WearableRepresentation } from './representation';
import { Metrics } from './metrics';
import { DisplayableDeployment } from '../shared/displayable';
import { MerkleProof } from '../merkle-tree';
import { WithRequired } from '../../misc';
/** @alpha */
export declare type Wearable = DisplayableDeployment & {
    id: string;
    name: string;
    description: string;
    data: {
        replaces: WearableCategory[];
        hides: WearableCategory[];
        tags: string[];
        representations: WearableRepresentation[];
        category: WearableCategory;
    };
    i18n: I18N[];
    thumbnail: string;
    image: string;
    rarity?: Rarity;
    collectionAddress?: string;
    metrics?: Metrics;
    content?: Record<string, string>;
    merkleProof?: MerkleProof;
};
/** @alpha */
export declare type StandardWearable = Omit<WithRequired<Wearable, 'collectionAddress' | 'rarity'>, 'merkleProof' | 'content'>;
export declare type ThirdPartyWearable = Omit<WithRequired<Wearable, 'merkleProof'>, 'rarity' | 'collectionAddress'>;
export declare const isStandard: (wearable: Wearable) => wearable is StandardWearable;
export declare const isThirdParty: (wearable: Wearable) => wearable is ThirdPartyWearable;
/** @alpha */
export declare namespace Wearable {
    const schema: JSONSchema<Wearable>;
    /**
     * Validates that the wearable metadata complies with the standard or third party wearable, and doesn't have repeated locales.
     * Some fields are defined as optional but those are validated to be present as standard XOR third party:
     *  Standard Wearables should contain:
     *    - collectionAddress
     *    - rarity
     *  Third Party Wearables should contain:
     *    - merkleProof
     */
    const validate: ValidateFunction<Wearable>;
}
//# sourceMappingURL=wearable.d.ts.map