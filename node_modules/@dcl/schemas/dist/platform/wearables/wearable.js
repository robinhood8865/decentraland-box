"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wearable = exports.isThirdParty = exports.isStandard = void 0;
const validation_1 = require("../../validation");
const rarity_1 = require("../../dapps/rarity");
const wearable_category_1 = require("../../dapps/wearable-category");
const i18n_1 = require("./i18n");
const representation_1 = require("./representation");
const metrics_1 = require("./metrics");
const displayable_1 = require("../shared/displayable");
const merkle_tree_1 = require("../merkle-tree");
const validateThirdParty = (wearable) => {
    if (!merkle_tree_1.MerkleProof.validate(wearable.merkleProof))
        return false;
    if (wearable.merkleProof.hashingKeys.length === 0)
        return false;
    const containsAllKeys = wearable.merkleProof.hashingKeys.every((key) => wearable.hasOwnProperty(key));
    const proofIsNotEmpty = wearable.merkleProof.proof.length > 0;
    return containsAllKeys && proofIsNotEmpty;
};
const validateStandardWearable = (rarity, collectionAddress) => rarity_1.Rarity.validate(rarity) && !!collectionAddress;
const isStandard = (wearable) => validateStandardWearable(wearable.rarity, wearable.collectionAddress);
exports.isStandard = isStandard;
const isThirdParty = (wearable) => validateThirdParty(wearable);
exports.isThirdParty = isThirdParty;
/** @alpha */
var Wearable;
(function (Wearable) {
    Wearable.schema = {
        type: 'object',
        properties: {
            ...displayable_1.displayableProperties,
            id: {
                type: 'string'
            },
            description: {
                type: 'string'
            },
            collectionAddress: {
                type: 'string',
                nullable: true
            },
            rarity: {
                ...rarity_1.Rarity.schema,
                nullable: true
            },
            name: {
                type: 'string'
            },
            i18n: {
                type: 'array',
                items: i18n_1.I18N.schema,
                minItems: 1
            },
            data: {
                type: 'object',
                properties: {
                    replaces: {
                        type: 'array',
                        items: wearable_category_1.WearableCategory.schema
                    },
                    hides: {
                        type: 'array',
                        items: wearable_category_1.WearableCategory.schema
                    },
                    tags: {
                        type: 'array',
                        items: {
                            type: 'string',
                            minLength: 1
                        }
                    },
                    representations: {
                        type: 'array',
                        items: representation_1.WearableRepresentation.schema,
                        minItems: 1
                    },
                    category: wearable_category_1.WearableCategory.schema
                },
                additionalProperties: false,
                required: ['replaces', 'hides', 'tags', 'representations', 'category']
            },
            thumbnail: {
                type: 'string'
            },
            image: {
                type: 'string'
            },
            metrics: {
                ...metrics_1.Metrics.schema,
                nullable: true
            },
            merkleProof: {
                ...merkle_tree_1.MerkleProof.schema,
                nullable: true
            },
            content: {
                type: 'object',
                nullable: true,
                additionalProperties: { type: 'string' },
                required: []
            }
        },
        additionalProperties: true,
        required: [
            'id',
            'description',
            'name',
            'data',
            'thumbnail',
            'image',
            'i18n'
        ]
    };
    const schemaValidator = (0, validation_1.generateValidator)(Wearable.schema);
    /**
     * Validates that the wearable metadata complies with the standard or third party wearable, and doesn't have repeated locales.
     * Some fields are defined as optional but those are validated to be present as standard XOR third party:
     *  Standard Wearables should contain:
     *    - collectionAddress
     *    - rarity
     *  Third Party Wearables should contain:
     *    - merkleProof
     */
    Wearable.validate = (wearable) => schemaValidator(wearable) &&
        validateDuplicatedLocales(wearable.i18n) &&
        XOR(validateStandardWearable(wearable.rarity, wearable.collectionAddress), validateThirdParty(wearable));
    const XOR = (b1, b2) => (b1 && !b2) || (b2 && !b1);
    // Returns true only if there are no entries with the same locale
    const validateDuplicatedLocales = (i18ns) => i18ns.every(({ code }, index) => i18ns.findIndex((i18n) => i18n.code === code) === index);
})(Wearable = exports.Wearable || (exports.Wearable = {}));
//# sourceMappingURL=wearable.js.map